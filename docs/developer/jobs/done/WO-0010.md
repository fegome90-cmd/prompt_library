# WO-0010: Reemplazar console.error con logger estructurado

## Metadatos
| Campo | Valor |
|-------|-------|
| id | WO-0010 |
| title | Reemplazar console.error con logger estructurado |
| type | chore |
| priority | P3 |
| area | BE |
| status |  Pending |

## Rationale
Hallazgo LOW: Logs sin estructura. console.error() en todos los catch dificulta debugging en producci贸n.

## Scope

### Include
- `src/lib/logger.ts` (crear)
- `src/app/api/**/*.ts` (actualizar imports)

### Exclude
- No modificar frontend
- No cambiar l贸gica de negocio

## Dependencies
Ninguna

## Acceptance Criteria
- [ ] Todos los catch blocks usan logger.error en lugar de console.error
- [ ] Logger incluye timestamp, level, message, y contexto opcional
- [ ] Logs tienen formato consistente

## Definition of Done

### Tests
- [ ] Logger exporta funciones: info, warn, error
- [ ] Logs aparecen en consola con formato consistente

### Security
- [ ] Logger no expone PII en mensajes

### Observability
- [ ] Todos los errores logueados con contexto

### Docs
- [ ] Comentario en logger explicando uso

### Evidence
- [ ] Ejemplo de output de logger
- [ ] Diff del cambio

## Verify

### Commands
```bash
# Lint
bun run lint

# Probar logger (trigger error manualmente)
curl http://localhost:3000/api/prompts/invalid-id
```

### Expected
- Lint pasa
- Log tiene formato estructurado

## Risk

### Failure Modes
- Logger demasiado verboso
- Formato incompatible con herramientas de logging

### Rollback
```bash
git revert <commit-hash>
```

## Notes
- Usar paquete ligero como pino o winston, o implementaci贸n simple
- Formato m铆nimo: `{timestamp, level, message, context?}`

## Implementaci贸n Sugerida

```typescript
// src/lib/logger.ts

type LogLevel = 'debug' | 'info' | 'warn' | 'error';

interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  context?: Record<string, unknown>;
}

const LOG_LEVELS: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};

const currentLevel: LogLevel = (process.env.LOG_LEVEL as LogLevel) || 'info';

function formatLog(entry: LogEntry): string {
  if (process.env.NODE_ENV === 'production') {
    return JSON.stringify(entry);
  }
  return `[${entry.timestamp}] ${entry.level.toUpperCase()}: ${entry.message}${entry.context ? ` ${JSON.stringify(entry.context)}` : ''}`;
}

export const logger = {
  debug(message: string, context?: Record<string, unknown>) {
    if (LOG_LEVELS.debug >= LOG_LEVELS[currentLevel]) return;
    console.debug(formatLog({
      timestamp: new Date().toISOString(),
      level: 'debug',
      message,
      context,
    }));
  },

  info(message: string, context?: Record<string, unknown>) {
    if (LOG_LEVELS.info >= LOG_LEVELS[currentLevel]) return;
    console.info(formatLog({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      context,
    }));
  },

  warn(message: string, context?: Record<string, unknown>) {
    if (LOG_LEVELS.warn >= LOG_LEVELS[currentLevel]) return;
    console.warn(formatLog({
      timestamp: new Date().toISOString(),
      level: 'warn',
      message,
      context,
    }));
  },

  error(message: string, context?: Record<string, unknown>) {
    console.error(formatLog({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      context,
    }));
  },
};

// Uso en catch blocks:
// Antes: console.error('Error al obtener prompts:', error);
// Despu茅s: logger.error('Error al obtener prompts', { error: error instanceof Error ? error.message : String(error) });
```

## Log de Cambios
| Fecha | Estado | Notas |
|-------|--------|-------|
| - |  Pending | Creado |
